<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zequn&#39;s Blog</title>
  
  <subtitle>Stay hungry Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zequnsong.github.io/"/>
  <updated>2020-10-22T08:35:24.960Z</updated>
  <id>https://zequnsong.github.io/</id>
  
  <author>
    <name>Zequn Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Binary Search</title>
    <link href="https://zequnsong.github.io/2020/10/21/Binary-Search/"/>
    <id>https://zequnsong.github.io/2020/10/21/Binary-Search/</id>
    <published>2020-10-22T05:26:34.000Z</published>
    <updated>2020-10-22T08:35:24.960Z</updated>
    
    <content type="html"><![CDATA[<hr><p>二分法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;二分法&lt;/p&gt;

      
    
    </summary>
    
      <category term="Algorithm" scheme="https://zequnsong.github.io/categories/Algorithm/"/>
    
    
      <category term="Binary Search" scheme="https://zequnsong.github.io/tags/Binary-Search/"/>
    
      <category term="二分法" scheme="https://zequnsong.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Uninformed Search</title>
    <link href="https://zequnsong.github.io/2019/05/02/Uninformed-Search/"/>
    <id>https://zequnsong.github.io/2019/05/02/Uninformed-Search/</id>
    <published>2019-05-03T06:05:11.000Z</published>
    <updated>2019-05-04T08:07:09.588Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Uninformed Search means agent doesn’t know how close a state is to the goal state.<br>Strategies that know whether one non-goal state is “more promising” than another are called Informed Search or Heuristic Search strategies; they are covered in next article.</p><img src="/2019/05/02/Uninformed-Search/search.jpg" title="BFS"><h4 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth-First Search"></a>Breadth-First Search</h4><p>The root node is expanded first, then all the successors of the root node are expanded next, then their successors, and so on. In general, all the nodes are expanded at a given depth in the search tree before any nodes at the next level are expanded.</p><p><img src="BFS.jpg" alt="BFS on a simple binary tree"></p><p>Frontier: a FIFO queue</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//-----------------------BREADTH-FIRST-SEARCH--------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BREADTH</span>-<span class="title">FIRST</span>-<span class="title">SEARCH</span><span class="params">(problem)</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">solution</span>, <span class="title">or</span> <span class="title">failure</span></span></span><br><span class="line">  node with STATE = problem.INITIAL-STATE, PATH-COST = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> problem.GOAL-TEST(node.STATE) then <span class="keyword">return</span> SOLUTION(node)</span><br><span class="line">  frontier = a FIFO queue with node as the only element</span><br><span class="line">  explored = an empty set</span><br><span class="line">  loop do</span><br><span class="line">    <span class="keyword">if</span> EMPTY?(frontier ) then <span class="keyword">return</span> failure</span><br><span class="line">    node = POP(frontier ) /* chooses the shallowest node in frontier */</span><br><span class="line">    add node.STATE to explored</span><br><span class="line">    <span class="keyword">for</span> each action in problem.ACTIONS(node.STATE) do</span><br><span class="line">      child = CHILD-NODE(problem, node, action)</span><br><span class="line">      <span class="keyword">if</span> child.STATE is not in explored or frontier then</span><br><span class="line">        //goal test is applied to each node when it is generated rather than when it is selected for expansion</span><br><span class="line">        <span class="keyword">if</span> problem.GOAL-TEST(child.STATE) then <span class="keyword">return</span> SOLUTION(child)</span><br><span class="line">        frontier = INSERT(child,frontier )</span><br></pre></td></tr></table></figure><p><strong>Evaluation</strong></p><ul><li><strong>Complete:</strong><br>If the shallowest goal node is at some finite depth d, breadth-first search will eventually find it after generating all shallower nodes (provided the branching factor b is finite).</li><li><strong>Not optimal:</strong><br>Only optimal when the path cost is a non-decreasing function of the depth of the node. The most common such scenario is that all actions have the same cost.</li><li><strong>Time complexity:</strong><br>Imagine branching factor is $b$ (each state has $b$ successors).<br>The root generates $b$ nodes at the first level.<br>Each of these generates $b$ more nodes, for a total of $b^2$ at the second level.<br>Each of these generates $b$ more nodes, yielding $b^3$ nodes at the third level, and so on.<br>Suppose that the solution is at depth $s$.<br>$$b + b^2 + b^3 + ··· + b^s = O(b^s)$$</li></ul><img src="/2019/05/02/Uninformed-Search/BFS2.jpg" title="BFS"><center><font color="#afaaaa" size="4">BFS</font></center><ul><li><strong>Space complexity:</strong><br>There will be $O(b^{s−1})$ nodes in the explored set and $O(b^s)$ nodes in the frontier.</li></ul><h4 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth-First Search"></a>Depth-First Search</h4><p>Always expands the deepest node in the current frontier of the search tree. The search proceeds immediately to the deepest level of the search tree, where the nodes have no successors. As those nodes are expanded, they are dropped from the frontier, so then the search “backs up” to the next deepest node that still has unexplored successors</p><p><img src="DFS.jpg" alt="DFS. The unexplored region is shown in light gray. Explored nodes with no descendants in the frontier are removed from memory. M is the only goal node."></p><p>Frontier: a LIFO queue</p><p><strong>Evaluation</strong></p><p>The properties of DFS strongly on whether the graph-search or tree-search version is used</p><ul><li><strong>Complete:</strong><br>Complete by graph-search if finite state space.<br>Not Complete by treee-search, maybe follow the loop forever.</li><li><strong>Not optimal:</strong><br>Return the leftmost solution.</li><li><strong>Time complexity:</strong><br>Imagine branching factor is $b$.<br>Suppose that maximum depth is $m$.<br>Therefore, time complexity is $O(b^m)$, bigger than BFS.<br>In tree search version, $m$ may be much larger than $d$ (the depth of shallowest solution).</li></ul><img src="/2019/05/02/Uninformed-Search/DFS2.jpg" title="DFS"><center><font color="#afaaaa" size="4">DFS</font></center><ul><li><strong>Space complexity:</strong><br>Only needs to store a single path from the root to a leaf node, along with the remaining unexpanded sibling nodes for each node on the path. Once a node has been expanded, it can be removed from memory as soon as all its descendants have been fully explored.<br>Therefore, DFS requires storage of only $O(bm)$ nodes. (if not use explored set)</li></ul><h4 id="Depth-Limited-Search"><a href="#Depth-Limited-Search" class="headerlink" title="Depth Limited Search"></a>Depth Limited Search</h4><p>The embarrassing failure of DFS in infinite state spaces can be alleviated by supplying DFS with a predetermined depth limit $l$. That is, nodes at depth $l$ are treated as if they have no successors.<br>DFS can be viewed as a special case of depth-limited search with $l=d$.</p><p><strong>Evaluation</strong></p><ul><li><strong>Not Complete:</strong> $l$ can be smaller than $s$.</li><li><strong>Not optimal:</strong> $l$ can be bigger than $d$.</li><li><strong>Time complexity:</strong> $O(b^l)$</li><li><strong>Space complexity:</strong> $O(bl)$</li></ul><h4 id="Iterative-Deepening-Search"><a href="#Iterative-Deepening-Search" class="headerlink" title="Iterative Deepening Search"></a>Iterative Deepening Search</h4><p>Get DFS’s space advantage with BFS’s time advantage. Repeat the DFS by gradually increasing the depth limit, until a goal is found.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//-----------------------BREADTH-FIRST-SEARCH--------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ITERATIVE</span>-<span class="title">DEEPENING</span>-<span class="title">SEARCH</span><span class="params">(problem)</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">solution</span>, <span class="title">or</span> <span class="title">failure</span></span></span><br><span class="line">  <span class="keyword">for</span> depth = <span class="number">0</span> to ∞ do</span><br><span class="line">    result ← DEPTH-LIMITED-SEARCH(problem, depth)</span><br><span class="line">    <span class="keyword">if</span> result != cutoff then <span class="keyword">return</span> result </span><br><span class="line">    //the cutoff value indicates no solution within the depth limit.</span><br></pre></td></tr></table></figure><p>Limit 0 is root node.<br>Run a DFS with depth limit 1. If no solution…<br>Run a DFS with depth limit 2. If no solution…<br>Run a DFS with depth limit 3. …</p><p><img src="IDS.jpg" alt="Four iterations of IDS on a binary tree."></p><p><strong>Evaluation</strong></p><ul><li><strong>Complete:</strong> same as BFS</li><li><strong>Not optimal:</strong> same as BFS</li><li><strong>Time complexity:</strong> $O(b^s)$<br>asymptotically the same as BFS<br>There is some extra cost for generating the upper levels multiple times, but it is not large.<br>For example, if $b = 10$ and $s = 5$, the numbers are<br>$N(IDS) = 50 + 400 + 3000 + 20000 + 100000 = 123450$<br>$N(BFS) = 10 + 100 + 1000 + 10000 + 100000 = 111110$</li><li><strong>Space complexity:</strong> $O(bs)$</li></ul><h4 id="Uniform-Cost-Search"><a href="#Uniform-Cost-Search" class="headerlink" title="Uniform Cost Search"></a>Uniform Cost Search</h4><p>BFS is only optima with non-decreasing cost function.<br>But UCS can find the least-cost(optimal) path with any step-cost function.<br>Instead of expanding the shallowest node, UCS expands the node n with the lowest $g(n)$ (which is path cost).</p><p>There are two other significant differences from breadth-first search. </p><ul><li>The first is that the goal test is applied to a node when it is selected for expansion rather than when it is first generated. The reason is that the first goal node that is generated may be on a suboptimal path. </li><li>The second difference is that a test is added in the end in case a better path is found to a node currently on the frontier</li></ul><p>Frontier: a priority queue (ordered by cumulative cost g(n))</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//----------------------- UNIFORM-COST-SEARCH--------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UNIFORM</span>-<span class="title">COST</span>-<span class="title">SEARCH</span><span class="params">(problem)</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">solution</span>, <span class="title">or</span> <span class="title">failure</span></span></span><br><span class="line">  node with STATE = problem.INITIAL-STATE, PATH-COST = <span class="number">0</span></span><br><span class="line">  frontier = a priority queue ordered by PATH-COST, with node as the only element</span><br><span class="line">  explored = an empty set</span><br><span class="line">  loop do</span><br><span class="line">    <span class="keyword">if</span> EMPTY?(frontier ) then <span class="keyword">return</span> failure</span><br><span class="line">    node = POP(frontier ) /* chooses the lowest-cost node in frontier */</span><br><span class="line">    if problem.GOAL-TEST(node.STATE) then return SOLUTION(node) //different goaltest location</span><br><span class="line">    add node.STATE to explored</span><br><span class="line">    <span class="keyword">for</span> each action in problem.ACTIONS(node.STATE) do</span><br><span class="line">      child = CHILD-NODE(problem, node, action)</span><br><span class="line">      <span class="keyword">if</span> child.STATE is not in explored or frontier then</span><br><span class="line">        frontier ← INSERT(child,frontier )</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> child.STATE is in frontier with higher PATH-COST then</span><br><span class="line">        replace that frontier node with child</span><br></pre></td></tr></table></figure><h6 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h6><p><img src="UCS2.jpg" alt="Part of the Romania state space"></p><p>The goal is to get from Sibiu to Bucharest.<br>Frontier={ Sibiu-0 }</p><p>The successors of Sibiu are Rimnicu Vilcea and Fagaras, with costs 80 and 99, respectively.<br>Frontier={ Rimnicu Vilcea-80, Fagaras-99 }</p><p>The least-cost node, Rimnicu Vilcea, is expanded.adding Pitesti with cost 80 + 97 = 177.<br>Frontier={ Fagaras-99, Pitesti-177 }</p><p>The least-cost node is now Fagaras, so it is expanded, adding Bucharest with cost 99 + 211 = 310.<br>Frontier={ Pitesti-177, Bucharest-310 }</p><p>Now a goal node has been generated, but UCS keeps going, no goal test now.<br>Choosing Pitesti for expansion and adding a second path to Bucharest with cost 80+ 97+ 101 = 278.<br>Frontier={ Bucharest(2)-278, Bucharest(1)-310 }</p><p>Choosing Bucharest(2), goal test now, the node to expand is goal state Bucharest with g-cost 278, the solution is returned.</p><p><strong>Evaluation</strong><br>UCS is guided by path costs rather than depths, so its complexity is not easily characterized in terms of $b$ and $d$.<br>Define some new variables:<br>$C^*$ is the cost for the optimal plan that reach the goal.<br>$\epsilon$ is the minimum cost for each action<br>Therefore, we will go at most $C^*/\epsilon$ deep.</p><p><img src="UCS.jpg" alt="UCS"></p><ul><li><strong>Complete:</strong><br>As long as there is a lower bound of the cost of each action ($\epsilon$ exist and $\epsilon&gt;0$)<br>UCS is a generalization of Breadth First Search in the sense that it takes costs of each edge into account. </li><li><strong>Optimal:</strong><br>Whenever UCS selects a node n for expansion, the optimal path to that node has been found, because our expand strategy is expands the node with the lowest path cost g(n)<br>Then, because step costs are non-negative, paths never get shorter as nodes are added.<br>These two facts together imply that UCS expands nodes in order of their optimal path cost.<br>Hence, the first goal node selected for expansion must be the optimal solution.</li><li><strong>Time complexity:</strong> $O(b^{C^*/\epsilon})$<br>Longer than BFS. BFS stops as soon as it generates a goal, whereas UCS examines all the nodes at the goal’s depth to see if one has a lower cost; thus UCS does strictly more work by expanding nodes at depth d unnecessarily.</li><li><strong>Space complexity:</strong> $O(b^{C^*/\epsilon})$  roughly the last tier</li></ul><p>Conceptually, all the search algorithms above are the same except for frontier strategies, and all frontier are priority queues (priority means strategy).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;Uninformed Search means agent doesn’t know how close a state is to the goal state.&lt;br&gt;Strategies that know whether one non-goal stat
      
    
    </summary>
    
      <category term="Artificial Intelligence" scheme="https://zequnsong.github.io/categories/Artificial-Intelligence/"/>
    
      <category term="Uninformed &amp; Informed Search" scheme="https://zequnsong.github.io/categories/Artificial-Intelligence/Uninformed-Informed-Search/"/>
    
    
      <category term="AI" scheme="https://zequnsong.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Tree Search</title>
    <link href="https://zequnsong.github.io/2019/04/27/Tree-Search/"/>
    <id>https://zequnsong.github.io/2019/04/27/Tree-Search/</id>
    <published>2019-04-28T06:37:58.000Z</published>
    <updated>2019-05-04T07:53:25.462Z</updated>
    
    <content type="html"><![CDATA[<hr><p>A problem-solving agent is one kind of goal-based agent. We already know that the characteristics of the environment dictate techniques for solving the problem. And the fast search techniques are suitable for known, observable, and deterministic environments.</p><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><p><strong>Known:</strong> the agent knows which states are reached by each action<br><strong>Observable:</strong> the agent always knows the current state<br><strong>Deterministic:</strong> each action has exactly one outcome</p><p>Before trying to solve the problem, we need to formulate the problem. </p><h4 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h4><ul><li><strong>Initial state</strong></li><li><strong>Actions &amp; Cost</strong></li><li><strong>Transition function:</strong> Result(state, action) = next state</li><li><strong>State space:</strong> include every possible state</li><li><strong>Goal test:</strong> which determines whether a given state is a goal state</li></ul><img src="/2019/04/27/Tree-Search/mapOfRomania.jpg" title="Map of Romania"><center><font color="#afaaaa" size="4">Map of Rimania</font></center><h6 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h6><p>Imagine an agent in the city of Arad, Romania. It wants to reach Bucharest.</p><ul><li>The environment is<br>– known: the agent has a map of Romania;<br>– observable: each city has a sign indicating its presence to arriving drivers;<br>– deterministic: if agent chooses to drive from Arad to Sibiu, it does end up in Sibiu.</li></ul><ul><li>The problem formulation is<br>– Initial state: Arad;<br>– Actions &amp; Cost: action == drive from city A to city B; cost == distance;<br>– Transition function: Result(current city, action) = next city – known from the map;<br>– State space: Cities on the map;<br>– Goal test: Is state == Bucharest?</li></ul><p>After formulated the problem, we now need to solve it. </p><h4 id="Tree-Search"><a href="#Tree-Search" class="headerlink" title="Tree Search"></a>Tree Search</h4><ul><li>Component of a search tree<br>– root : initial state<br>– nodes: states in state space<br>– branches : actions<br>– frontier (open list): a queue which contains all leaf nodes available for expansion</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//------------informal description of the general tree-search---------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TREE</span>-<span class="title">SEARCH</span><span class="params">(problem)</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">solution</span>, <span class="title">or</span> <span class="title">failure</span></span></span><br><span class="line">  initialize the frontier using the initial state of problem</span><br><span class="line">  loop do</span><br><span class="line">    <span class="keyword">if</span> the frontier is empty then <span class="keyword">return</span> failure</span><br><span class="line">    choose a leaf node and remove it from the frontier</span><br><span class="line">    <span class="keyword">if</span> the node contains a goal state then <span class="keyword">return</span> the corresponding solution</span><br><span class="line">    expand the chosen node, adding the resulting nodes to the frontier</span><br><span class="line">    </span><br><span class="line">//---------------------- node of the search tree-------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CHILD</span>-<span class="title">NODE</span><span class="params">(problem, parent, action)</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">node</span></span></span><br><span class="line">  <span class="keyword">return</span> a node with</span><br><span class="line">    STATE = problem.RESULT(parent.STATE, action),</span><br><span class="line">    PARENT = parent, ACTION = action,</span><br><span class="line">    PATH-COST = parent.PATH-COST + problem.STEP-COST(parent.STATE, action)</span><br></pre></td></tr></table></figure><p>The node has PARENT pointer, solution is the sequence of actions obtained by following parent pointers back to the root.</p><p><img src="searchTree.jpg" alt="Partial search trees for finding a route from Arad to Bucharest"></p><h6 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h6><p>Figure above shows the partial search trees for finding a route from Arad to Bucharest</p><ul><li><p>Component of the search tree<br>– root : Arad<br>– nodes (shaded): nodes that have been expanded;<br>– nodes (outlined in bold): nodes that have been generated but not yet expanded;<br>– nodes (dashed lines): nodes that have not yet been generated;<br>– branches : parent node -&gt; child node;<br>– frontier (open list): nodes outlined in bold;</p></li><li><p>Tree-Search<br>initial frontier = { Arad };<br><strong>step1: </strong>remove Arad from frontier;<br><strong>step2: </strong>current city == goal city ? return solution : do step3.;<br><strong>step3: </strong>expand current city to adjacent cities: Sibiu, Timisoara, Zerind. Add them to frontier;<br><strong>step4: </strong>if frontier is not empty, choose a city to expand according to some strategy, and do step234 recurrently;<br><strong>step5: </strong>if frontier is not empty, return false.</p></li></ul><h4 id="Graph-Search"><a href="#Graph-Search" class="headerlink" title="Graph Search"></a>Graph Search</h4><p>Sometimes redundant paths are unavoidable, e.g. Arad -&gt; Sibiu -&gt; Arad …The way to avoid exploring redundant paths is to remember where one has been.<br>To do this, we augment the TREE-SEARCH algorithm with a data structure called the <strong>explored set</strong> (also known as the <strong>closed list</strong>), which remembers every expanded node.<br>Newly generated nodes that match previously generated nodes—ones in the explored set or the frontier—can be discarded instead of being added to the frontier. The new algorithm, called GRAPH-SEARCH.</p><p>The closed list should be implemented with a <strong>hash table</strong> to allow efficient checking for repeated states.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">------------informal description of the general graphe-search---------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GRAPH</span>-<span class="title">SEARCH</span><span class="params">(problem)</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">solution</span>, <span class="title">or</span> <span class="title">failure</span></span></span><br><span class="line">  initialize the frontier using the initial state of problem</span><br><span class="line">  initialize the explored set to be empty</span><br><span class="line">  loop do</span><br><span class="line">    <span class="keyword">if</span> the frontier is empty then <span class="keyword">return</span> failure</span><br><span class="line">    choose a leaf node and remove it from the frontier</span><br><span class="line">    <span class="keyword">if</span> the node contains a goal state then <span class="keyword">return</span> the corresponding solution</span><br><span class="line">    add the node to the explored set</span><br><span class="line">    expand the chosen node, adding the resulting nodes to the frontier</span><br><span class="line">      only <span class="keyword">if</span> not in the frontier or explored set</span><br></pre></td></tr></table></figure><p>In fact, all search algorithms share the structures above, they vary primarily according to how they choose which state to expand next – the so-called <strong>search strategy</strong>.</p><p>We have two different search strategies, <strong>Uninformed Search</strong> and <strong>Informed Search</strong>, which will be covered in next two articles.</p><h4 id="Evaluation-Criteria-for-Algorithms"><a href="#Evaluation-Criteria-for-Algorithms" class="headerlink" title="Evaluation Criteria for Algorithms"></a>Evaluation Criteria for Algorithms</h4><p>Before we get into the design of specific search strategies, we need to consider the criteria that might be used to choose among them. We can evaluate an algorithm’s performance in<br>four ways:</p><ul><li><strong>Completeness:</strong> Is the algorithm guaranteed to find a solution when there is one?</li><li><strong>Optimality:</strong> Does the strategy find the optimal solution?</li><li><strong>Time complexity:</strong> How long does it take to find a solution?</li><li><strong>Space complexity:</strong> How much memory is needed to perform the search?</li></ul><p>In AI, complexity is expressed in terms of three quantities: </p><ul><li><strong> $b$:</strong> the branching factor or maximum number of successors of any node; </li><li><strong> $d$:</strong> the depth of the shallowest goal node (i.e., the number of steps along the path from the root);</li><li><strong> $m$:</strong> the maximum length of any path in the state space. </li></ul><p>Time is often measured in terms of the number of nodes generated during the search.<br>Space in terms of the maximum number of nodes stored in memory.</p><h6 id="Source-of-pictures-for-this-article"><a href="#Source-of-pictures-for-this-article" class="headerlink" title="Source of pictures for this article:"></a>Source of pictures for this article:</h6><p>Russell and Norvig (2010). Artificial Intelligence: A Modern Approach.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;A problem-solving agent is one kind of goal-based agent. We already know that the characteristics of the environment dictate techniq
      
    
    </summary>
    
      <category term="Artificial Intelligence" scheme="https://zequnsong.github.io/categories/Artificial-Intelligence/"/>
    
      <category term="Uninformed &amp; Informed Search" scheme="https://zequnsong.github.io/categories/Artificial-Intelligence/Uninformed-Informed-Search/"/>
    
    
      <category term="AI" scheme="https://zequnsong.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to AI</title>
    <link href="https://zequnsong.github.io/2019/04/27/Introduction-to-AI/"/>
    <id>https://zequnsong.github.io/2019/04/27/Introduction-to-AI/</id>
    <published>2019-04-28T06:09:22.000Z</published>
    <updated>2019-04-28T06:12:16.317Z</updated>
    
    <content type="html"><![CDATA[<hr><img src="/2019/04/27/Introduction-to-AI/cover.png" width="800" height="200" title="What is AI ?"><p>What is AI? </p><p>Nowadays, AI means designing a rational agent, which could act rationlly to choose the action that maximizes its expected utility.</p><h4 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h4><p>An agent is an entity that perceives and acts. A rational agent selects actions that maximize its expected utility. Characteristics of the percepts, environment, and action space dictate techniques for selecting rational actions.</p><p>An agent needs sensors to sense the information of the environment, and also needs actuators to take actions based on perceived information.</p><p><img src="AgentInAI.jpg" width="300" height="120" alt="How agent works"></p><h4 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h4><p>This and following articles are about general AI techniques for a variety of problem types and learning to recognize when and how a new problem can be solved with an existing technique.</p><p>The following articles will cover AI in two parts:</p><ul><li>Part I: Making Decisions<ul><li>Uninformed and Informed Search</li><li>Constraint Satisfaction Problem</li><li>Adversarial and Uncertain Search</li></ul></li></ul><ul><li>Part II: Reasoning under Uncertainty<ul><li>Markov Decision Problem</li><li>Reinforcement Learning</li><li>Markov Model &amp; Hidden Markov Model</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;img src=&quot;/2019/04/27/Introduction-to-AI/cover.png&quot; width=&quot;800&quot; height=&quot;200&quot; title=&quot;What is AI ?&quot;&gt;
&lt;p&gt;What is AI? &lt;/p&gt;
&lt;p&gt;Nowadays, AI 
      
    
    </summary>
    
      <category term="Artificial Intelligence" scheme="https://zequnsong.github.io/categories/Artificial-Intelligence/"/>
    
      <category term="Introduction to AI" scheme="https://zequnsong.github.io/categories/Artificial-Intelligence/Introduction-to-AI/"/>
    
    
      <category term="AI" scheme="https://zequnsong.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>TagPlugins Test</title>
    <link href="https://zequnsong.github.io/2019/04/27/TagPlugins-Test/"/>
    <id>https://zequnsong.github.io/2019/04/27/TagPlugins-Test/</id>
    <published>2019-04-28T06:08:58.000Z</published>
    <updated>2019-04-28T06:24:53.380Z</updated>
    
    <content type="html"><![CDATA[<hr><p>In Hexo, Tag Plugins are used for inserting specific content into the article. Let me show you how it works here.</p><h2 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>Example: </p><blockquote><p>Use all the parameters</p><footer><strong>Zequn Song, A book of Genius</strong><cite><a href="https://zequnsong.github.io">Zequn's blog</a></cite></footer></blockquote><blockquote><p>Don’t worry, Tweet happy. (Quote from twitter)</p><footer><strong>@Twitter</strong><cite><a href="https://twitter.com/Twitter/status/1119338115989213185" target="_blank" rel="noopener">twitter.com/Twitter/status/1119338115989213185</a></cite></footer></blockquote><h2 id="Code-Block"><a href="#Code-Block" class="headerlink" title="Code Block"></a>Code Block</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [lang:language] [description] [source_link for description]%&#125;</span><br><span class="line">code</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight java"><figcaption><span>test-java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Test for code block"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;</span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/Zequn/0v7j29ep/1/embedded/js,html,css,result/dark" frameborder="0" allowfullscreen></iframe><h2 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h2><p>Embed with js:</p><script src="https://gist.github.com/ZequnSong/08f61c6d1c146014a297eadf486bacef.js" file="index.html"></script><p>Embed with tag plugins:</p><script src="//gist.github.com/08f61c6d1c146014a297eadf486bacef.js?file=index.html"></script><p>Gist Preview on bl.ocks: <a href="https://bl.ocks.org/ZequnSong/08f61c6d1c146014a297eadf486bacef" target="_blank" rel="noopener">https://bl.ocks.org/ZequnSong/08f61c6d1c146014a297eadf486bacef</a></p><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>can be used to embed web, video, music</p><iframe src="http://v.youku.com/v_show/id_XOTIxNDYzODU2.html" width="930" height="542" frameborder="0" allowfullscreen></iframe><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><img src="/2019/04/27/TagPlugins-Test/dfeb310fcf5b3751849d6c6278e05299.jpg" width="920" height="613" title="example picture"><p><img src="1-1PG6122T4.jpg" alt="test markdown"></p><h2 id="youtube"><a href="#youtube" class="headerlink" title="youtube"></a>youtube</h2><div class="video-container"><iframe src="//www.youtube.com/embed/whrb7UfKBeU" frameborder="0" allowfullscreen></iframe></div><h2 id="vimeo"><a href="#vimeo" class="headerlink" title="vimeo"></a>vimeo</h2><div class="video-container"><iframe src="//player.vimeo.com/video/330553859" frameborder="0" allowfullscreen></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;In Hexo, Tag Plugins are used for inserting specific content into the article. Let me show you how it works here.&lt;/p&gt;
&lt;h2 id=&quot;Quote&quot;
      
    
    </summary>
    
      <category term="Hexo" scheme="https://zequnsong.github.io/categories/Hexo/"/>
    
      <category term="Tag Plugins" scheme="https://zequnsong.github.io/categories/Hexo/Tag-Plugins/"/>
    
    
  </entry>
  
</feed>
